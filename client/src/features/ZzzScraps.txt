-----------------------------------------------

***IMPORTANT*** FROM LitTextsContainer WETTER SORT METHODS ***IMPORTANT*** 
	const authorAZ = (texts) => {
		let toMap = [...texts]
		let mappedArr = toMap.map((text) => `${text.last_name} ${text.id}`)
		let sortedAuthors = mappedArr.sort()
		let sortedArr = sortedAuthors.map((auth) => {
			let sortID = auth.replace(/^\w.+\s/, "")
			let sortText = toMap.find((text) => parseInt(text.id) === parseInt(sortID))
			return sortText
		})
		return sortedArr		
	}

	const titleAZ = (texts) => {
		let toMap = [...texts]
		let mappedArr = toMap.map((text) => `${text.title} ${text.id}`)
		let sortedTitles = mappedArr.sort()
		let sortedArr = sortedTitles.map((title) => {
			let sortID = title.replace(/^\w.+\s/, "")
			let sortText = toMap.find((text) => parseInt(text.id) === parseInt(sortID))
			return sortText
		})
		return sortedArr
	}

	const byPubdate = (texts) => [...texts].sort((a, b) => a.pubdate - b.pubdate)

	const recentlyAdded = (texts) => {
		let toSort = [...texts]
		let sortArr = toSort.sort((a, b) => {
			let dateTimeA = Date.parse(a.created_at) 
			let dateTimeB = Date.parse(b.created_at)
			return dateTimeB - dateTimeA
		})
		return sortArr
	}

	const newestComment = (el) => {
		let toSort = [...el.comments]
		let sortArr = toSort.sort((a, b) => {
			let dateTimeA = Date.parse(a.created_at) 
			let dateTimeB = Date.parse(b.created_at)
			return dateTimeB - dateTimeA
		})
		if (sortArr.length === 0) {
			return 0
		} else {
			let newest = sortArr[0]
			let newestCreatedAt = Date.parse(newest.created_at)
			return newestCreatedAt
		}
	}

	const recentlyCommented = (texts) => {
		let toSort = [...texts]
		let sortArr = toSort.sort((a, b) => newestComment(b) - newestComment(a))
		return sortArr
	}										

-----------------------------------------------

***IMPORTANT*** FROM ComRepShow TEST REPLIES UNDER RIGHT COMMENT ***IMPORTANT*** 
	const checkRepliesUnderCorrectComment = () => {
		return (
			<span style={{ fontSize: 10 }} >(
				<span>id: {renderComment.id}</span>
				{renderComment.parent_comment_id ? <span>, replying to: {renderComment.parent_comment_id}</span>: null}) 
			</span>		
		)
	}

						checkRepliesUnderCorrectComment()

-----------------------------------------------











LESS IMPORTANT:

-----------------------------------------------

-----------------------------------------------

-----------------------------------------------

-----------------------------------------------

FROM UserTextComPreview COMMENT PREVIEW
	const contentSlice = comment.content.slice(0, 35)
	const showContent = contentSlice.replace(/\s.\w+$/, "")

						<Typography variant="body2" sx={{ }} >{showContent}&nbsp;.&nbsp;.&nbsp;.</Typography>

-----------------------------------------------

FROM About DRAFT OF DEPENDENCIES ARRAY TO DRY UP CODE
	const dependencyLinks = [
		["MUI", "https://mui.com/"],
		["Quill", "https://quilljs.com/"],
		["React-Quill", "https://github.com/zenoamaro/react-quill"],
		["html-react-parser, "https://github.com/remarkablemark/html-react-parser#readme"],
		["Rails Html Sanitizers, "https://github.com/rails/rails-html-sanitizer"],
		["bcrypt", "https://github.com/bcrypt-ruby/bcrypt-ruby"],
	]

							>Flatiron</a>. It's coded using JS, React, Redux, Ruby, and Rails, along with <a
							href="https://mui.com/"
							rel="noreferrer" target="_blank" 
							style={{ color: "#455a64"}}
						>MUI</a>, <a
							href="https://quilljs.com/"
							rel="noreferrer" target="_blank" 
							style={{ color: "#455a64"}}
						>Quill</a>, and a few other dependencies. You can see the repo on <a

			<Grid 
				item xs={9} 
				align="center" 
				justify="center">
					<Typography id="top" variant="h2" sx={{ pt:4, pb:3, fontWeight: 399 }}>About <span> </span>
							<Box component="span" sx={{ fontFamily: "Didot", fontWeight: "440", fontSize: 90 }}>
								Marginalia
							</Box>
					</Typography>
			</Grid>

							<li>
								Securely sign up, log in, log out, and remain authorized on refresh
							</li>
							<li>
								Upload poems, stories, and other literary texts 
							</li>
							<li>
								Edit texts they uploaded
							</li>
							<ul>
								<li>
									Or, if the user is a &ldquo;librarian&rdquo; user-type, edit any uploaded text
								</li>
							</ul>
							<li>
								Browse, search, filter, and read those texts
							</li>
							<li>
								Post comments on texts and replies to other comments
							</li>
							<li>
								Edit and delete their own comments
							</li>
							<ul>
								<li>
									If a comment has replies or is a reply, deleting it will leave a ghost that says &ldquo;comment was deleted&rdquo; rather than simply vanishing
								</li>
							</ul>
							<li>
								Assign their comments multiple comment types, such &ldquo;question&rdquo; or &ldquo;critique&rdquo;
							</li>
							<ul>
								<li>
									Add and remove comment types from their comments
								</li>
							</ul>
							<li>
								Browse, search, and filter all comments on a particular text
							</li>
							<li>
								Browse, search, and filter other users&rsquo; profiles
							</li>
							<li>
								Edit their own profile
							</li>
							<li>
								Delete their account
							</li>


-----------------------------------------------

FROM ComRepShow BEFORE :NAME METHOD ON BACKEND
	// const renderName = () => comment.user.fam_name_first ? 
	// 	`${comment.user.last_name} ${comment.user.first_name}` : 
	// 	`${comment.user.first_name} ${comment.user.last_name}`

-----------------------------------------------

FROM OrderDropdown DIRECTION FUNCTIONS
	const directionStyle = { 
		color: "#616161", 
		fontSize: "85%", 
		paddingLeft: "4px" 
	}

	const directionLabel = (val) => {
		let valTag = val.slice(val.length - 3)
		if (valTag === "A-Z") {
			return "(a-z)"
		} else if (valTag === "Z-A") {
			return "(z-a)"
		} else if (valTag === "New") {
			return "(newest first)"
		} else if (valTag === "Old") {
			return "(oldest first)"
		}
	}

	const directionElement = (val) => {
		return (
			<span style={directionStyle}>
				{directionLabel(val)}
			</span>
		)
	}
	
-----------------------------------------------

FROM FilterDropDown WET MENUITEMS
				<MenuItem value="all">
					All 
				</MenuItem>
				<MenuItem value="poetry">
					Poetry 
				</MenuItem>
				<MenuItem value="prose">
					Prose 
				</MenuItem>

-----------------------------------------------

FROM LitTextsContainer STATE OBJECT
	const [stateObjLTC, setStateObjLTC] = useState({
		filteredLitTexts: [...litTextsArr],
		litTextsOrder: "author",
		isReversed: false,
		newClicked: false,
		poetryProseValue: "all"
	})

	// FROM useEffect:
		setStateObjLTC(prev => {return ({
			...prev,
			filteredLitTexts: [...litTextsArr]
		})})	

-----------------------------------------------

FROM OrderDropdown BEFORE REVERSE BUTTON
	const valuesArr = [
		["authorA-Z", "Author"],
		["authorZ-A", "Author"],
		["titleA-Z", "Title"],
		["titleZ-A", "Title"],
		["dateNew", "Date"],
		["dateOld", "Date"],
		["activityNew", "Activity"],
		["activityOld", "Activity"],
		["addedNew", "Added"],
		["addedOld", "Added"]
	]

	const directionStyle = { 
		color: "#616161", 
		fontSize: "85%", 
		paddingLeft: "4px" 
	}

	const directionLabel = (val) => {
		let valTag = val.slice(val.length - 3)
		if (valTag === "A-Z") {
			return "(a-z)"
		} else if (valTag === "Z-A") {
			return "(z-a)"
		} else if (valTag === "New") {
			return "(newest first)"
		} else if (valTag === "Old") {
			return "(oldest first)"
		}
	}

	const directionElement = (val) => {
		return (
			<span style={directionStyle}>
				{directionLabel(val)}
			</span>
		)
	}
	
	return (
		<FormControl sx={{ minWidth: "252px", mt: 1, }} >
			<Paper sx={{ bgcolor: "#fefcf9", }}>
			<InputLabel id="arrange-by-label">Arrange By</InputLabel>
			<Select
				labelId="arrange-by-label"
				id="arrange-by"
				value={litTextsOrder}
				label="Arrange By"
				onChange={handleLitTextsOrder}
				sx={{ bgcolor: "#fefcf9", minWidth: "232px" }}
			>
				{valuesArr.map((valueArr, index) => {
					return (
						<MenuItem 
							key={index} 
							value={valueArr[0]}
						>
							{valueArr[1]} {directionElement(valueArr[0])}
						</MenuItem>
					)
				})}
			</Select>
			<Box component="span" sx={{ border: '2px grey' }}>
			<IconButton sx={{ border: '2px grey' }}>
				<CompareArrowsIcon sx={{ transform: "rotate(90deg)"}}/>
			</IconButton>
			</Box>
			</Paper>
		</FormControl>
	)
}

-----------------------------------------------

FROM LitTextsContainer MEDIUM-DRY RENDER FUNCTION
	const renderLitTexts = () => {
		let filtArr = filterRawArr([...filteredLitTexts])
		let arrTwo = []
		if (litTextsOrder === "authorA-Z") {
			arrTwo = [...authorAZ(filtArr)]
		} else if (litTextsOrder === "authorZ-A") {
			arrTwo = [...authorAZ(filtArr).reverse()]
		} else if (litTextsOrder === "titleA-Z") {
			arrTwo = [...titleAZ(filtArr)]
		} else if (litTextsOrder === "titleZ-A") {
			arrTwo = [...titleAZ(filtArr).reverse()]
		} else if (litTextsOrder === "dateNew") {
			arrTwo = [...byPubdate(filtArr)]
		} else if (litTextsOrder === "dateOld") {
			arrTwo = [...byPubdate(filtArr).reverse()]
		} else if (litTextsOrder === "activityNew") {
			arrTwo = [...recentlyCommented(filtArr)]
		} else if (litTextsOrder === "activityOld") {
			arrTwo = [...recentlyCommented(filtArr).reverse()]
		} else if (litTextsOrder === "addedNew") {
			arrTwo = [...recentlyAdded(filtArr)]
		} else if (litTextsOrder === "addedOld") {
			arrTwo = [...recentlyAdded(filtArr).reverse()]
		}
		let toMap = [...arrTwo]
		let mappedArr = toMap.map((text) => <LitTextListShow key={text.id} litText={text} />)
		return mappedArr
	}

-----------------------------------------------

FROM UsersContainer ALPHABETICAL SORT FUNCTION
	const alphabetical = (users) => 
		[...users].map((user) => 
			`${user.last_name} ${user.id}`)
		.sort()
		.map((nameId) => 
			users.find((user) => 
			parseInt(user.id) === parseInt(nameId.replace(/^\w.+\s/, ""))
		)
	)

-----------------------------------------------

FROM LastName NAME LABEL FUNCTION
	const nameLabel = (nameType) => {
		if (isAuthor && nameType === "Given") {
			return "Author's given name(s)"
		} else if (isAuthor) {
			return "Author's family name" 
		} else {
			return `${nameType} name`
		}
	}

-----------------------------------------------

FROM LitTextNewForm PREVIEW & SUBMIT BUTTON TERNARIES
					{storyOrPoem === "Story" || storyOrPoem === "Poem" ?
						<div style={{ width: "100%", display: "flex", justifyContent: "center", textAlign: "center"  }}>
						<Tooltip title="Check out the preview before you submit" arrow>
							<Button 
								onClick={handlePreviewClick}
								variant="contained"
								sx={{ mt: 2, }}
							>
								Preview
							</Button>
						</Tooltip>
						</div>
					:
						<div style={{ width: "100%", display: "flex", justifyContent: "center", textAlign: "center"  }}>
							<Tooltip title="Select POETRY or PROSE first" arrow>
								<span>
									<Button
										disabled
										variant="contained"
										sx={{ mt: 2, }}
									>
										Preview
									</Button>
								</span>
							</Tooltip>
						</div>
					}

					{previewClicked && (storyOrPoem === "Story" || storyOrPoem === "Poem") ? 
						<div>
							<br/>
							<Paper 
								elevation={9} 
								sx={{ p:3, m: 1, mx: "8%", backgroundColor: "#fefcf9" }}
							>
								<Grid container wrap="nowrap">
									<Grid item xs={12}>
								<Typography variant="h6" sx={{ textAlign:"center", textColor: "#616161", fontVariant: "small-caps", mb: 1 }}><em>preview</em></Typography>
								<Typography variant="h4" sx={{ textAlign:"center" }}><b>{formData.title}</b></Typography>
								<Typography variant="h6" sx={{ textAlign:"center" }}>{`${formData.first_name} ${formData.last_name}`}</Typography>
								<Typography variant="subtitle1" sx={{ textAlign:"center" }}><em>{displayDate()}</em></Typography>
									<Grid container wrap="nowrap">
										<Grid item xs={12} justifyContent="center" sx={{ display: "flex", }}>
											<div style={{ position: "flex", }} >
												<Typography variant="body1" sx={{ pb:3, pr:3, pl:3, pt:2, }}>
													{parseQuillData()}
												</Typography>
												</div>
										</Grid>
									</Grid>
								</Grid>
								</Grid>
							</Paper>
							<br/>

							{quillData.length > 0 && (storyOrPoem === "Story" || storyOrPoem === "Poem") ?
								<div style={{ width: "100%", display: "flex", justifyContent: "center", }}>
									<Button
										type="submit"
										variant="contained"
										sx={{ mt: 1, mb: 2, }}
									>
										Submit
									</Button>
								</div>
							:
								<div style={{ width: "100%", display: "flex", justifyContent: "center", }}>
									<Tooltip title="Text cannot be blank" arrow>
										<span>
											<Button
												disabled
												variant="contained"
												sx={{ mt: 2, mb: 2, }}
											>
												Submit
											</Button>
										</span>
									</Tooltip>
								</div>
							}
						</div>
					:
						<div style={{ width: "100%", display: "flex", justifyContent: "center", }}>
							<Tooltip title="Check out the Preview first" arrow>
								<span>
									<Button
										disabled
										variant="contained"
										sx={{ mt: 2, mb: 2, }}
									>
										Submit
									</Button>
								</span>
							</Tooltip>
						</div>
					}

-----------------------------------------------

FROM OrderDropdown WET MENUITEMS
				<MenuItem value="authorA-Z">
					Author {directionElement("authorA-Z")}
				</MenuItem>
				<MenuItem value="authorZ-A">
					Author {directionElement("authorZ-A")}
				</MenuItem>
				<MenuItem value="titleA-Z">
					Title {directionElement("titleA-Z")}
				</MenuItem>
				<MenuItem value="titleZ-A">
					Title {directionElement("titleZ-A")}
				</MenuItem>
				<MenuItem value="dateNew">
					Date {directionElement("dateNew")}
				</MenuItem>
				<MenuItem value="dateOld">
					Date {directionElement("dateOld")}
				</MenuItem>
				<MenuItem value="activityNew">
					Activity {directionElement("activityNew")}
				</MenuItem>
				<MenuItem value="activityOld">
					Activity {directionElement("activityOld")}
				</MenuItem>
				<MenuItem value="addedNew">
					Added {directionElement("addedNew")}
				</MenuItem>
				<MenuItem value="addedOld">
					Added {directionElement("addedOld")}
				</MenuItem>

-----------------------------------------------


FROM LitTextNewForm FIRST & LAST NAME INPUTS
						<Grid container item xs={12} sx={{ mx: "5%", my: 1, width: "90%"}}>
							<Grid item xs sx={{ mr: "5px" }}>
								<TextField
									onChange={handleFormChange}
									autoComplete="first_name"
									name="first_name"
									id="first_name"
									sx={{ mr: 1, backgroundColor: "#fff", width: "100%" }}
									label="Author's first name"
								/>
							</Grid>
							<Grid item xs="auto">
								<CompareArrowsIcon sx={{ height: "62px", color: "#3e2723", cursor: "pointer" }}/>
							</Grid>
							<Grid item xs sx={{ ml: "5px" }}>
								<TextField
									onChange={handleFormChange}
									autoComplete="last_name"
									name="last_name"
									required
									id="last_name"
									sx={{ backgroundColor: "#fff", width: "100%" }}
									label="Author's last name"
								/>
							</Grid>
						</Grid>


-----------------------------------------------


FROM LitTextNewForm TOOLTIPS
						{/* <Tooltip title="You may include middle names and initials" placement="top" arrow> */}

						{/* </Tooltip>
						<Tooltip title="If an author only has one name, include it here" placement="top" arrow> */}
						{/* <Tooltip title={<span>For where to put particles like <em>de</em> or <em>von,</em> see the <a href="https://libguides.dickinson.edu/citing/mla7capitalization/" rel="noreferrer" target="_blank" style={{ color: "#c9dee8" }}>MLA guidelines</a></span>} placement="bottom" arrow> */}

						{/* </Tooltip> */}
						{/* </Tooltip> */}


-----------------------------------------------



FROM ComRepShow NAME & AVATAR SPACING
			<Grid item >
				<Avatar 
						alt={renderComment.fullname} 
						src={renderComment.image} 
						sx={{ cursor: "pointer", width: 60, height: 60, mt: '5px', }} 
						onClick={() => userClicked()} 
					/>
			</Grid>
			<Grid justifyContent="left" item xs={9}>
				<Typography 
					variant="h6" 
					onClick={userClicked} 
					sx={{ cursor: "pointer", mb: 0, pb: 0 }} 
				>
					{renderComment.fullname}
				</Typography>


-----------------------------------------------


FROM CommentNewForm CHECKBOXES
	function handleCheck(e) {
		// console.log("fired")
		if (!formData.com_type_ids.includes(parseInt(e.target.value))) {
			let comTypes = [...formData.com_type_ids, parseInt(e.target.value)]
			setFormData({
				...formData,
				com_type_ids: [...comTypes],
			})
		} else {
			let comTypes = formData.com_type_ids.filter((c) => parseInt(c) !== parseInt(e.target.value))
			setFormData({
				...formData,
				com_type_ids: [...comTypes],
			})
		}
	}

						<div style={{ display: "flex", justifyContent: "center", }}>

						<label>
							<Checkbox id="1" name="reading" value="1" onChange={(e) => handleCheck(e)} />
							<Typography variant="caption">Reading</Typography>
						</label>
						<label>
							<Checkbox id="2" name="question" value="2" onChange={(e) => handleCheck(e)} />
							<Typography variant="caption">Question</Typography>
						</label>
						<label>
							<Checkbox id="3" name="footnote" value="3" onChange={(e) => handleCheck(e)} />
							<Typography variant="caption">Footnote</Typography>
						</label>
						{parentCommentId ? 
							<label>
								<Checkbox id="4" name="answer" value="4" onChange={(e) => handleCheck(e)} sx={{ bgcolor: "#fff" }} />
								<Typography variant="caption">Answer</Typography>
							</label>
						: null}
						</div>


-----------------------------------------------


FROM LitTextsContainer SMOOTH TO TOP BUTTON
import { HashLink } from 'react-router-hash-link'
						<div id="new" style={{ width: "100%", display: "flex", justifyContent: "center", textAlign: "center"  }}>
							<HashLink smooth to="/texts#top">
							<Button 
								// onClick={handleNewClick}
								variant="contained"
								sx={{ mt: 2, mb: 4}}
							>
								Top
							</Button>
							</HashLink>
						</div>


-----------------------------------------------


FROM LitTextsContainer ADD NEW BUTTON
							<Tooltip title="Add New Story or Poem" arrow>
								<Button
									onClick={() => handleNewClick()} 
									variant="contained"
									sx={{ py: 1, ml: 5, mt: "9px" }}
								>
									<AddBoxIcon fontSize="large" fontColor="#fefcf9"/>
								</Button>
							</Tooltip>


-----------------------------------------------


FROM LitTextsContainer DROPDOWN
							<FormControl sx={{ minWidth: "250px", ml: 10, bgcolor: "#fffaf5" }} >
								<InputLabel id="arrange-by-label">Arrange By</InputLabel>
								<Select
									labelId="arrange-by-label"
									id="arrange-by"
									value={litTextsOrder}
									label="Arrange By"
									onChange={handleLitTextsOrder}
									// sx={{ p: 1 }}
								>
									<MenuItem value="authorAZ">
										Author 
										<span style={directionStyle}>
											(a-z)
										</span>
									</MenuItem>
									<MenuItem value="titleAZ">
										Title
										<span style={directionStyle}>
											(a-z)
										</span>
									</MenuItem>
									<MenuItem value="recentComment">
										Activity
										<span style={directionStyle}>
											(newest first)
										</span>
									</MenuItem>
									<MenuItem value="recentlyAdded">
										Added
										<span style={directionStyle}>
											(newest first)
										</span>
									</MenuItem>
								</Select>
							</FormControl>


-----------------------------------------------


FROM LitTextsContainer DIRECTION ICON

	const [orderReverse, setOrderReverse] = useState(false)
	const handleOrderReverse = () => {
		setOrderReverse(prev => !prev)
	}
							<Box sx={{ bgcolor: "#eae4e1", ml: 10, width: 276 }} >
							<FormControl  variant="standard" sx={{ minWidth: "200px", }} >
								<InputLabel id="arrange-by-label">Arrange By</InputLabel>
								<Select
									labelId="arrange-by-label"
									id="arrange-by"
									value={litTextsOrder}
									label="Arrange By"
									onChange={handleLitTextsOrder}
									sx={{ p: 1 }}
								>
									<MenuItem value="authorAZ" sx={{ alignContent: "center" }} >
										Author (a-z)
									</MenuItem>
									<MenuItem value="titleAZ">Title</MenuItem>
									<MenuItem value="recentlyAdded">Date Added</MenuItem>
									<MenuItem value="recentComment">Latest Comment</MenuItem>
								</Select>
							</FormControl>
							<OrderButtonContainer
								handleOrderReverse={handleOrderReverse} 
								orderReverse={orderReverse}										
							/>
							</Box>	


-----------------------------------------------


FROM LitTextsContainer TOGGLEBUTTONS
	import { Typography, Grid, ToggleButton, ToggleButtonGroup, Box, TextField, Button, Tooltip } from '@mui/material'

							{/* <ToggleButtonGroup
								value={litTextsOrder}
								exclusive
								onChange={handleLitTextsOrder}
								aria-label="Arrange Users"
								sx={{ bgcolor: "#fffaf5", }}
							>
								<ToggleButton 
									value="authorAZ"
									aria-label="Author A-Z"
								>
									Author A-Z
								</ToggleButton>
								<ToggleButton 
									value="titleAZ"
									aria-label="Title A-Z"
								>
									Title A-Z
								</ToggleButton>
								<ToggleButton 
									value="recentlyAdded"
									aria-label="Most recently added"
								>
									Recently Added
								</ToggleButton>
								<ToggleButton 
									value="recentComment"
									aria-label="Most recent comment"
								>
									Recent Activity
								</ToggleButton>
							</ToggleButtonGroup> */}


-----------------------------------------------


FROM LitTextNewForm WITH CONDITIONALS ADDSTORYORPOEMETC
export default function LitTextNewForm() {
	const [isHidden, setIsHidden] = useState(false)
	const [storyOrPoem, setStoryOrPoem] = useState("Poem")
	const [formData, setFormData] = useState({
		title: "",
		author: "",
		pubdate: "",
		content: "",
		prose: false
	})
	const [quillData, setQuillData] = useState("")
	const [addStoryOrPoem, setAddStoryOrPoem] = useState("Add a New Poem")
	const [previewClicked, setPreviewClicked] = useState(false)
	const [areYouSure, setAreYouSure] = useState(<span>Are you sure your submission is a <b>POEM?</b></span>)

	const errors = useSelector(state => state.litTexts.errors)
	const dispatch = useDispatch()

	const handlePreviewClick = () => {
		setPreviewClicked(!previewClicked)
	}

	const handleProseBoolean = (b) => {
		setFormData(formData => {return ({
			...formData,
			prose: b
		})})
	}

	const handleStoryOrPoemClick = (event, value) => {
		setStoryOrPoem(value)
		if (value === "Story") {
			handleProseBoolean(true)
			setAddStoryOrPoem(`Add a New Story or Other Prose Work`)
			setAreYouSure(<span>Are you sure your submission is a <b>STORY</b> or other prose work?</span>)
		} else if (value === "Poem") {
			handleProseBoolean(false)
			setAddStoryOrPoem(`Add a New ${value}`)
			setAreYouSure(<span>Are you sure your submission is a <b>POEM?</b></span>)
		} else {
			setAddStoryOrPoem(`Add a New Story or Poem`)
			setAreYouSure(<span>Is your submission a <b>POEM</b>? Or is it a <b>STORY</b> or other prose work?</span>)

		}
	}

	const handleFormChange = (e) => {
		setFormData((formData) => {
			return (
				{
					...formData,
					[e.target.name]: e.target.value,
				}
			)
		})
	}

	const handleQuillChange = (content) => {
		console.log("handleQuillCHANGE", content)
		setQuillData(content)
	}

	const parseQuillData = () => {
		let parsedData = parse(`${quillData}`)
		if (storyOrPoem === "Poem") {
			return (<div className="poetry">{parsedData}</div>)
		} else {
			return (<div>{parsedData}</div>)
		}
	}

	const handleSubmit = (e) => {
		e.preventDefault()
		let parsedData = parseQuillData()
		handleFormChange({ target: { name: "content", value: parsedData } })
		console.log("handleSubmit.formData:", formData)
		dispatch(postLitText(formData))
	}

	const qFormats = [
		'header', 'bold', 'italic', 'underline', 'strike', 'blockquote',
    'list', 'bullet', 'indent'
	]

	const qModules = {
    toolbar: [
      [{ 'header': [1, 2, 3, false] }],
      ['bold', 'italic', 'underline','strike', 'blockquote'],
      [{'list': 'ordered'}, {'list': 'bullet'}, {'indent': '-1'}, {'indent': '+1'}],
      ['clean']
    ],
  }

	return (
		<Grid item xs={12}>
			<Paper 
				elevation={6} 
				sx={{ p:3, m: 3, backgroundColor: "#fffaf5" }}
			>
				<Typography 
					variant="h5" 
					sx={{ textAlign:"center", mb: 1 }} 
				>
					<b>{addStoryOrPoem}</b>
				</Typography>

				<Box textAlign="center">
					<ToggleButtonGroup
						value={storyOrPoem}
						exclusive
						onChange={handleStoryOrPoemClick}
						aria-label="Story or Poem"
						sx={{ bgcolor: "#fff3e6", my: 1 }}
					>
						<ToggleButton 
							value="Story"
							aria-label="Story"
						>
							It's Prose
						</ToggleButton>
						<ToggleButton 
							value="Poem"
							aria-label="Poem"
						>
							It's Poetry
						</ToggleButton>
					</ToggleButtonGroup>
				</Box>

				<form display="flex" onSubmit={handleSubmit} >
					<TextField
						onChange={handleFormChange}
						autoComplete="title"
						name="title"
						required
						
						id="title"
						label="Title"
						autoFocus
						sx={{ mx: "5%", my: 1, backgroundColor: "#fff", width: "90%" }}
					/>
					<TextField
						onChange={handleFormChange}
						autoComplete="author"
						name="author"
						required
						id="author"
						sx={{ mx: "5%", my: 1, backgroundColor: "#fff", width: "90%" }}
						label="Author"
					/>
					<TextField
						onChange={handleFormChange}
						autoComplete="pubdate"
						name="pubdate"
						required
						id="pubdate"
						label="Year"
						sx={{ mt: 1, mb: 2, mx: "5%", backgroundColor: "#fff", width: "90%" }}
					/>
					<ReactQuill 
						theme="snow"
						value={quillData}
						onChange={handleQuillChange}
						placeholder="Paste and edit the text of the story or poem here"
						style={{ 
							backgroundColor: "#fff", 
							width: "90%",
							marginRight: "5%",
							marginLeft: "5%"
						}}
						formats={qFormats}
						modules={qModules}
					/>

						<div style={{ width: "100%", display: "flex", justifyContent: "center", textAlign: "center"  }}>
						<Tooltip title="Check out the preview before you submit" arrow>
							<Button 
								onClick={handlePreviewClick}
								variant="contained"
								sx={{ mt: 2, p: 2 }}
							>
								Preview
							</Button>
						</Tooltip>
						</div>
						{errors?errors.map(e => <div key={e.id} style={{ color: "#660033", textAlign: "center" }} >{e}</div>):null}
            {previewClicked ? 
							<div>
								<br/>
								<Paper 
									elevation={9} 
									sx={{ p:3, m: 1, mx: "8%", backgroundColor: "#fefcf9" }}
								>
									<Grid container wrap="nowrap">
										<Grid item xs={12}>
									<Typography variant="h6" sx={{ textAlign:"center", textColor: "#616161", fontVariant: "small-caps", mb: 1 }}><em>preview</em></Typography>
									<Typography variant="h4" sx={{ textAlign:"center" }}><b>{formData.title}</b></Typography>
									<Typography variant="h6" sx={{ textAlign:"center" }}>{formData.author}</Typography>
									<Typography variant="subtitle1" sx={{ textAlign:"center" }}><em>{formData.pubdate}</em></Typography>
										<Grid container wrap="nowrap">
											<Grid item xs={12} justifyContent="center" sx={{ display: "flex", }}>
												<div style={{ position: "flex", }} >
													<Typography variant="body1" sx={{ pb:3, pr:3, pl:3, pt:2, }}>
														{parseQuillData()}
													</Typography>
													</div>
											</Grid>
										</Grid>
									</Grid>
									</Grid>
								</Paper>
								<br/>
								<div style={{ color: "#660033", textAlign: "center", width: "100%" }} >{areYouSure}</div>
								<br/>
								{quillData.length > 0 && (storyOrPoem === "Story" || storyOrPoem === "Poem") ?
									<div style={{ width: "100%", display: "flex", justifyContent: "center", }}>
										<Button
											type="submit"
											variant="contained"
											sx={{ mt: 1, mb: 2, p: 2 }}
										>
											Submit
										</Button>
									</div>
								:
									<div style={{ width: "100%", display: "flex", justifyContent: "center", }}>
											<Button
												disabled
												variant="contained"
												sx={{ mt: 2, mb: 2, p: 2 }}
											>
												Submit
											</Button>
									</div>
								}
							</div>
						:
							<div style={{ width: "100%", display: "flex", justifyContent: "center", }}>
									<Button
										disabled
										variant="contained"
										sx={{ mt: 2, mb: 2, p: 2 }}
									>
										Submit
									</Button>
							</div>
						}
				</form>
			</Paper>
		</Grid>
	)
}


-----------------------------------------------


FROM litTextsSlice 
export const postLitText = createAsyncThunk(
	"litTexts/postLitText",
	async (formData) => {
		const response = await fetch("/lit_texts", {
			method: "POST",
			headers: {
				"Content-Type": "application/json",
			},
			body: JSON.stringify(formData),
		})
		if(!response.ok) {
			return Promise.reject();
		}
		return await response.json();	
	}
)


-----------------------------------------------


FROM LitTextsContainer OLD TERNARY WITH SORRY ERROR 
				{status === "idle" ? 
					<div>
						<Box textAlign="center">
							<ToggleButtonGroup
								value={litTextsOrder}
								exclusive
								onChange={handleLitTextsOrder}
								aria-label="Arrange Users"
								sx={{ bgcolor: "#fffaf5", }}
							>
								<ToggleButton 
									value="authorAZ"
									aria-label="Author A-Z"
								>
									Author A-Z
								</ToggleButton>
								<ToggleButton 
									value="titleAZ"
									aria-label="Title A-Z"
								>
									Title A-Z
								</ToggleButton>
								<ToggleButton 
									value="recentlyAdded"
									aria-label="Most recently added"
								>
									Recently Added
								</ToggleButton>
								<ToggleButton 
									value="recentComment"
									aria-label="Most recent comment"
								>
									Recent Activity
								</ToggleButton>
							</ToggleButtonGroup>
							<br/>
							<TextField 
								id="search"
								label="Search"
								variant="filled"
								sx={{ m: 2, mt: 3, width: "50%" }}
								onChange={e => handleSearch(e)}
							/>
						</Box>
						{renderLitTexts()}
						{<LitTextNewForm litText={null} />}
					</div>
				: status === "loading" ?
					<div className="centered-in-window" >
							<h1>Loading...</h1>
					</div>
				: <div className="centered-in-window" >
							<h1>We're sorry. There's been an error</h1>
					</div>
				}


-----------------------------------------------


FROM LitTextNewForm OLD PARSE W <BR/>
	const parseQuillData = () => {
		let parseData = quillData
		if (storyOrPoem === "Poem") {
			parseData = quillData.replaceAll("</p><p>", "<br/>")
		}
		let returnData = parse(`${parseData}`)
		return (<div>{returnData}</div>)
	}


-----------------------------------------------


FROM LitTextNewForm UNNECESSARY HANDER FUNCTIONS FOR QUILL DATA
	const handleFormContent = (data) => {
		setFormData(formData => {return ({
			...formData,
			content: data
		})})
	}

	const handleFormConditional = () => {
		if (formData.prose) {
			handleFormContent(quillData)		
		}	else {
			let 
		}
	}

	const handleQuillSubmit = (content) => {
		console.log("handleQuillSUBMIT", content)
		let cfg = {} 
		let converter = new QuillDeltaToHtmlConverter(content, cfg)
		let contentHTML = converter.convert()
		let parsedContent = parse(`${contentHTML}`)
	}


-----------------------------------------------


FROM LitTextNewForm TEXTFIELD FOR HTML
					<TextField
						onChange={handleFormChange}
						autoComplete="content"
						name="content"
						required
						fullWidth
						id="content"
						label="Content HTML"
						sx={{ 
							mt: 2,
							mb: 1, 
							mx: "10%", 
							backgroundColor: "#fefcf9", 
							width: "80%",
							visibility: isHidden ? "hidden" : "visible" 
						}}
					/>

					
-----------------------------------------------


FROM LitTextNewForm OLD PROSE/POETRY CONDITIONAL
	const [errors, setErrors] = useState([])
	const [isHidden, setIsHidden] = useState(false)
	const [storyOrPoem, setStoryOrPoem] = useState("")
	const isProse = () => storyOrPoem === "Story" ? true : false
	const [formData, setFormData] = useState({
		title: "",
		author: "",
		pubdate: "",
		content: "",
		prose: isProse()
	})
	const [quillData, setQuillData] = useState("")
	const [addStoryOrPoem, setAddStoryOrPoem] = useState("Add a New Story or Poem")
	// const [pasteStoryOrPoem, setPasteStoryOrPoem] = useState('story or poem')
	
	const handleStoryOrPoemClick = (event, value) => {
		setStoryOrPoem(value)
		setAddStoryOrPoem(`Add a New ${value}`)
		// setPasteStoryOrPoem(`${value.toLowerCase()}`)
	}


-----------------------------------------------


FROM LitTextNewForm ADD OR EDIT
	let addOrEdit = "Add a New Story or Poem"
	if (litText) {
		if (litText.prose) {
			addOrEdit = "Edit Story"
		} else {
			addOrEdit = "Edit Poem"
		}
	}

	if (litText) setFormData(litText)


-----------------------------------------------


USESELECT FOR USER
  const userArr = useSelector((state) => state.user.entities)
  const user = userArr.length > 0 ? userArr[0] : null



-----------------------------------------------



FROM litTextsSlice
	extraReducers: {
		[fetchLitTexts.pending](state) {
			state.status = "loading"
		},
		[fetchLitTexts.fulfilled](state, action) {
			state.entities = action.payload
			state.status = "idle"
		}
	},


	export const fetchLitTexts = createAsyncThunk("litTexts/fetchLitTexts", () => {
	return fetch("/lit_texts")
    .then((r) => r.json())
    .then((data) => data.sort((a, b) => b.id - a.id))
})



-----------------------------------------------



FROM litTextsApi
	import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

	export const litTextsApi = createApi({
		reducerPath: 'litTextApi',
		baseQuery: fetchBaseQuery({ baseUrl: '/'}),
		endpoints: (builder) => ({
			getLitTexts: builder.query({
				query: () => 'lit_texts',
			}),
			getLitTextById: builder.query({
				query: (id) => `lit_texts/${id}`,
			}),
		}),
	})

	export const { useGetLitTextsQuery, useGetLitTextbyIdQuery } = litTextsApi



-----------------------------------------------



FROM CommentNewForm
	function handleCheck(e) {
		if (comTypes.includes(parseInt(e.target.value))) {
			setComTypes((prevState) => {
				let newArr = prevState.filter((c) => parseInt(c.id) !== parseInt(e.target.value))
				return [...newArr]
			})
			// let filteredComTypes = comTypes.filter((c) => parseInt(c.id) !== parseInt(e.target.value))
			// setComTypes([...filteredComTypes])
			// setFormData({
			// 	...formData,
			// 	com_type_ids: filteredComTypes,
			// })
		console.log("did include", comTypes)
		} else {
			// let addedComTypes = comTypes.push(parseInt(e.target.value))
			setComTypes((prevState) => [...prevState, parseInt(e.target.value)])
			// setFormData({
			// 	...formData,
			// 	com_type_ids: addedComTypes,
			// })
		console.log("did not include", comTypes)
		}
		// console.log("end", comTypes)
	}



-----------------------------------------------



FROM TimeAgoContainer.js 
	if (created_at === updated_at) {
		secondTerm = null
	} else if (isDeleted) {
		secondTerm = <em>, deleted: <TimeAgo time={updated_at} />
				</em> 
	} else {
		secondTerm = <em>, updated: <TimeAgo time={updated_at} />
				</em>
	}



-----------------------------------------------



FROM seeds.rb 
	7.times do
		parent_comment_id=Comment.ids.sample
		user_id=User.ids.sample
		lit_text_id=LitText.ids.sample
		content=Faker::Lorem.paragraph
		Comment.create(user_id: user_id, lit_text_id: lit_text_id, parent_comment_id: parent_comment_id, content: content, deleted:false)
	end



-----------------------------------------------



FROM ReplyShow
	export default function ReplyShow({ reply, user, allUsers }) {

		const replyUser = allUsers.find((u) => parseInt(u.id) === parseInt(reply.user_id))

		return(
			<div style={{ padding: 10 }} >
				<div style={{ borderStyle: "solid", borderWidth: 1, padding: 5 }} >
					<h4>{replyUser.username}</h4>
							
				</div>
			</div>
		)
	}



-----------------------------------------------



FROM CommentShow
	<p style={{ fontSize: 10 }} ><em>posted: {comment.created_at}</em></p>
	{comment.created_at === comment.updated_at ? null : <span style={{ fontSize: 10, paddingLeft: 20 }} ><em>updated: {comment.updated_at}</em></span>}

	*

	const filteredReplies = replies.filter((r) => parseInt(r.user_id) === parseInt(commentUser.id))
	


-----------------------------------------------



FROM UserShow
	let showBio = ""
	bio ? showBio = `${bio.slice(0, 30)}...` : showBio = ""



-----------------------------------------------



FROM LitTextListShow
	const rawContent = content ? content.slice(0, 100) : ""
	const showContent = rawContent.replace(/(<([^>]+)>)/gi, " ")



-----------------------------------------------



FROM LitTextShow
	// import { QuillDeltaToHtmlConverter } from 'quill-delta-to-html'

	// console.log(litText)
	// let QuillDeltaToHtmlConverter = require('quill-delta-to-html').QuillDeltaToHtmlConverter
	// let cfg = {}
	// let rawContent = [{"insert":"Sometimes the notes are ferocious,\nskirmishes against the author\nraging along the borders of every page\nin tiny black script.\nIf I could just get my hands on you,\nKierkegaard, or Conor Cruise O’Brien,\nthey seem to say,\nI would bolt the door and beat some logic into your head.\n\nOther comments are more offhand, dismissive –\n“Nonsense.” “Please!” “HA!!” –\nthat kind of thing.\nI remember once looking up from my reading,\nmy thumb as a bookmark,\ntrying to imagine what the person must look like\nwho wrote “Don’t be a ninny”\nalongside a paragraph in "},{"attributes":{"italic":true},"insert":"The Life of Emily Dickinson."},{"insert":"\n\nStudents are more modest\nneeding to leave only their splayed footprints\nalong the shore of the page.\nOne scrawls “Metaphor” next to a stanza of Eliot’s.\nAnother notes the presence of “Irony”\nfifty times outside the paragraphs of "},{"attributes":{"italic":true},"insert":"A Modest Proposal."},{"insert":"\n\nOr they are fans who cheer from the empty bleachers,\nhands cupped around their mouths.\n“Absolutely,” they shout\nto Duns Scotus and James Baldwin.\n“Yes.” “Bull’s-eye.” “My man!”\nCheck marks, asterisks, and exclamation points\nrain down along the sidelines.\n\nAnd if you have managed to graduate from college\nwithout ever having written “Man vs. Nature”\nin a margin, perhaps now\nis the time to take one step forward.\n\nWe have all seized the white perimeter as our own\nand reached for a pen if only to show\nwe did not just laze in an armchair turning pages;\nwe pressed a thought into the wayside,\nplanted an impression along the verge.\n\nEven Irish monks in their cold scriptoria\njotted along the borders of the Gospels\nbrief asides about the pains of copying,\na bird singing near their window,\nor the sunlight that illuminated their page–\nanonymous men catching a ride into the future\non a vessel more lasting than themselves.\n\nAnd you have not read Joshua Reynolds,\nthey say, until you have read him\nenwreathed with Blake’s furious scribbling.\n\nYet the one I think of most often,\nthe one that dangles from me like a locket,\nwas written in the copy of"},{"attributes":{"italic":true},"insert":" Catcher in the Rye"},{"insert":"\nI borrowed from the local library\none slow, hot summer.\nI was just beginning high school then,\nreading books on a davenport in my parents’ living room,\nand I cannot tell you\nhow vastly my loneliness was deepened,\nhow poignant and amplified the world before me seemed,\nwhen I found on one page\n\na few greasy looking smears\nand next to them, written in soft pencil–\nby a beautiful girl, I could tell,\nwhom I would never meet–\n“Pardon the egg salad stains, but I’m in love.”\n"}]
	// let converter = new QuillDeltaToHtmlConverter(rawContent, cfg)
	// console.log("converter", converter)
	// let contentHTML = converter.convert()
	// console.log("contentHTML", contentHTML)

	{/* <p>{rawContent}</p> */}


------------


FROM Signup

			{ hasAccount ? 
				<div style={{ padding: 15 }} >
				<Login onLogin={onLogin} />
				<div className="txt-centered-in-div" >or</div>
				<button 
				onClick={handleClick} 
				className="centered-in-div" 
				>Signup for a New Account</button>
				</div>
				:
				<div style={{ padding: 15 }} >
				<Signup onLogin={onLogin} />
				<div className="txt-centered-in-div" >or</div>
				<button onClick={handleClick} className="centered-in-div" >Login to Your Account</button>
				</div>
			}

